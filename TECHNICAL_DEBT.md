## بدهی‌های فنی و بهبودهای پس از نسخه اول (V1)

این سند، بهبودهای Best Practice را برای پس از انتشار نسخه پایدار اول ثبت می‌کند. در V1 تمرکز روی تحویل سریع قابلیت‌هاست؛ این موارد برای افزایش پایداری، امنیت، مشاهده‌پذیری و نگهداشت در نسخه‌های بعد اعمال می‌شوند.

### مدل داده و RBAC
- ثبت رویدادها (Audit) – در V2 اضافه شود:
  - ستون‌های درون‌جدولی: created_by, updated_by, deleted_by (FK به users) کنار created_at, updated_at, deleted_at.
  - جدول مرکزی Audit Log (append‑only) با تریگر/هوک اپلیکیشن: شامل table_name, record_id, action, actor_id, request_id, ip_address, occurred_at, before/after JSON.
  - الگوی ترکیبی: ستون‌های سبک داخل هر جدول + جدول مرکزی برای تاریخچه کامل.
  - چرایی: برای ردیابی اینکه «چه کسی، چه زمانی، چه تغییری» انجام داده و پاسخ‌گویی/گزارش‌گیری.
  - پیامد عدم انجام: دشواری عیب‌یابی، نبود ردپا در مسائل امنیتی/کشف خطا.
  - گام اجرا: افزودن ستون‌های audit به جداول اصلی، سپس ایجاد جدول مرکزی + تریگرها.
- قیود و ایندکس‌ها:
  - یکتا بودن `permission_categories.name` و `permissions.slug`.
  - ایندکس روی created_at/updated_at/deleted_at برای گزارش‌های زمانی.
  - چرایی: جلوگیری از داده‌های ناسازگار و بهبود کارایی کوئری‌ها.
  - پیامد عدم انجام: ورود داده تکراری/متضاد، کندی گزارش‌ها.
  - گام اجرا: اعمال UNIQUE/INDEX در مایگریشن بعدی و اصلاح داده‌های متضاد احتمالی.
- سیاست حذف نرم (Soft Delete):
  - اعمال شرط `deleted_at IS NULL` در کوئری‌های پیش‌فرض و فیلتر مدیریتی برای آرشیوی‌ها.
  - چرایی: حفظ تاریخچه و امکان بازیابی رکوردها.
  - پیامد عدم انجام: از دست رفتن دائم داده‌ها یا اختلاط رکوردهای حذف‌شده با فعال‌ها.
  - گام اجرا: افزودن اسکوپ پیش‌فرض در لایه دیتا/ریپو و فیلتر UI.
- یکپارچگی مراجع:
  - تعریف FK برای پیوت‌ها (`permission_role`, `role_user`) با ON DELETE CASCADE/SET NULL طبق قواعد دامنه.
  - چرایی: تضمین سازگاری ارتباطات نقش/دسترسی/کاربر.
  - پیامد عدم انجام: orphan records و نتایج پیش‌بینی‌ناپذیر.
  - گام اجرا: افزودن FKها با سیاست حذف مناسب و پاک‌سازی داده‌های یتیم.

- بازبینی طول ستون‌ها (Right‑sizing)
  - وضعیت فعلی: اغلب ستون‌های متنی طول 255 دارند (name/slug/description/model و ...).
  - پیشنهاد:
    - `slug`: معمولاً 100 یا کمتر کافی است (پایدار و کوتاه نگه‌دار).
    - `name` و `title`: 150–191 برای سازگاری با ایندکس‌ها (collation/utf8mb4).
    - `description`: در صورت نیاز به متن بلندتر، `TEXT` به‌جای `VARCHAR(255)`.
    - `model`: اگر مقدار از دامین محدودی می‌آید، enum/reference table یا حداکثر 100 کاراکتر.
  - چرایی: کاهش مصرف ذخیره‌سازی، بهبود کارایی ایندکس‌ها و جلوگیری از برش داده.
  - پیامد عدم انجام: ایندکس‌های ناکارآمد، محدودیت‌های غیرضروری یا داده‌های ناقص.
  - گام اجرا: ممیزی همه ستون‌های متنی، تعیین طول هدف، اعمال مهاجرت غیرشکننده؛ برای ستون‌های ایندکس‌شده، توجه به محدودیت طول ایندکس در utf8mb4.

### API و یکپارچه‌سازی بک‌اند
- استانداردسازی ارسال کانتکست Audit:
  - هدرهای فرانت: X‑Audit‑Request‑Id, X‑Audit‑Actor‑Id, X‑Client‑IP.
  - میدل‌ور بک‌اند: نگاشت هدرها به Session DB و ثبت در لاگ‌ها.
  - چرایی: اتصال مطمئن بین لایه کاربر و ردپای دیتابیس.
  - پیامد عدم انجام: ناهمگونی بین لاگ اپ و لاگ دیتابیس.
  - گام اجرا: افزودن میدل‌ور و ست‌کردن Session Variable قبل از کوئری‌ها.
- خطاها و مشاهده‌پذیری:
  - کدهای خطای یکنواخت، request_id در پاسخ‌ها و لاگ‌ها.
  - لاگ ساختاریافته (JSON): timestamp, level, request_id, actor_id, route, latency.
  - چرایی: عیب‌یابی سریع، همبستگی رخدادها، مانیتورینگ SLA.
  - پیامد عدم انجام: سختی پیگیری باگ‌ها و کندی پاسخ به رخدادها.
  - گام اجرا: تعریف استاندارد پاسخ خطا و راه‌اندازی logger ساختاریافته.
- اعتبارسنجی و قراردادها:
  - DTO/Validator مشترک (مثلاً zod) برای ورودی/خروجی.
  - نسخه‌بندی API در صورت احتمال تغییرات شکاف‌دار.
  - چرایی: جلوگیری از خطاهای قرارداد و سازگاری بین کلاینت/سرور.
  - پیامد عدم انجام: بروز خطاهای زمان اجرا و ناسازگاری نسخه‌ها.
  - گام اجرا: معرفی لایه DTO و تست‌های قرارداد.

### فرانت‌اند (Next.js/React/TS)
- بهبود DataTable:
  - صفحه‌بندی/مرتب‌سازی سمت سرور برای داده‌های بزرگ؛ سمت کلاینت برای کوچک.
  - تنظیمات ستون: کلید پایدار، دسترس‌پذیری (aria‑sort)، ناوبری کیبورد.
  - چرایی: کارایی و تجربه کاربری بهتر در داده‌های حجیم.
  - پیامد عدم انجام: کندی UI و لگ در لیست‌های بزرگ.
  - گام اجرا: API لیست‌ها را server‑driven و DataTable را pluggable کنیم.
- احراز هویت و گاردها:
  - نقشه متمرکز مجوزها؛ تابع type‑safe برای `hasPermission` جهت جلوگیری از خطای اسلاگ.
  - وضعیت‌های عدم دسترسی با پیام راهنمای اقدام.
  - چرایی: جلوگیری از باگ‌های دسترسی و بهبود راهنمای کاربر.
  - پیامد عدم انجام: خطاهای دسترسی و سردرگمی کاربر.
  - گام اجرا: استخراج نگاشت مجوزها و بهبود پیام‌های UI.
- بهبود UI/UX:
### مدیریت وضعیت (State Management)
- وضعیت فعلی: useState/useEffect محلی + AuthContext سراسری. داده‌های لیست‌ها در سطح کامپوننت نگهداری می‌شود.
- پیشنهاد:
  - برای وضعیت سراسری سبک (preferences، فیلترهای مشترک، پنل): Zustand یا Context + reducer.
  - برای داده‌های سروری (CRUD/لیست‌ها): React Query (TanStack Query) برای cache، refetch، وضعیت درحال‌بارگزاری و خطا.
  - جداسازی concerns: هوک‌های دامین برای orchestration (use[Feature]Management) و سرویس‌ها برای I/O.
- چرایی: کاهش پیچیدگی پراکندگی state، همگام‌سازی ساده با سرور، تست‌پذیری بهتر.
- گام اجرا: نصب Zustand/React Query، تعریف store‌های سبک، مهاجرت تدریجی لیست‌ها به Query + cache.

### اعتبارسنجی فرم‌ها (Validation)
- وضعیت فعلی: required و setCustomValidity پراکنده در JSX.
- پیشنهاد Best Practice:
  - Schema-based: zod برای تعریف قوانین (Role/Permission/Category) + zodResolver در react-hook-form.
  - Localization: پیام‌های فارسی متمرکز در validators/faValidation.ts یا در خود schema‌ها.
  - Reusable Field: یک Field مشترک (label/control/error) تا نمایش خطاها یکسان شود.
  - Selectهای غیر-native: ست‌کردن خطا از طریق RHF (setError) نه setCustomValidity.
- چرایی: حذف تکرار، پیام‌های یکنواخت، تست‌پذیری schemaها.
- گام اجرا: نصب zod @hookform/resolvers، ایجاد role.schema.ts / permission.schema.ts / category.schema.ts و مهاجرت فرم Upsert.
  - Empty state، اسکلت لودر، به‌روزرسانی خوش‌بینانه با بازگشت.
  - بازبینی RTL برای دیالوگ/تولتیپ/دراپ‌داون.
  - چرایی: حس کیفیت و پاسخ‌گویی بالاتر.
  - پیامد عدم انجام: تجربه کاربری ضعیف در شبکه‌های کند.
  - گام اجرا: افزودن اسکلت‌ها و الگوهای optimistic با fallback.

### امنیت
- اصول حداقل دسترسی برای تمام اندپوینت‌ها.
- CSRF برای درخواست‌های تغییرstate (در صورت کوکی‑بیس).
- Rate limiting و جلوگیری از حملات brute‑force روی احراز هویت.
- مدیریت امن متغیرهای محیطی؛ عدم نگه‌داری رازها در کد.
  - چرایی: کاهش سطح حمله و حفاظت از داده‌ها.
  - پیامد عدم انجام: ریسک نفوذ و نشت اطلاعات.
  - گام اجرا: فعال‌سازی لایه‌های محافظ و بازبینی دوره‌ای.

### تست و کیفیت
- خودکارسازی:
  - TypeScript strict، ESLint، Prettier، مرتب‌سازی ایمپورت‌ها.
  - تست واحد برای ابزارها و اجزای بحرانی؛ تست یکپارچه برای Auth و RBAC.
- سناریوهای QA دستی برای هر صفحه:
  - CRUD، مجوزها، RTL، سورت/جستجو/صفحه‌بندی DataTable.
  - چرایی: جلوگیری از بازگشت خطاها و تضمین کیفیت در تحویل.
  - پیامد عدم انجام: افزایش باگ‌های تولید و هزینه نگهداشت.
  - گام اجرا: افزودن تسک‌های CI و حداقل پوشش تست.

### تجربه توسعه و تحویل
- CI/CD:
  - lint/typecheck/test روی PR و استقرار پیش‌نمایش.
- نسخه‌دهی و گزارش تغییرات:
  - نسخه‌دهی معنایی و نگه‌داری CHANGELOG.md.
  - چرایی: شفافیت در تحویل و قابلیت ردیابی.
  - پیامد عدم انجام: ابهام در نسخه‌ها و سختی بازگشت.
  - گام اجرا: تنظیم خطوط لوله CI و مستندسازی نسخه‌ها.

### کارایی
- کداسپلیت و lazy‑load برای مسیرهای سنگین.
- مموییزیشن و مجازی‌سازی برای جدول‌های بزرگ.
- بهینه‌سازی تصاویر و منابع.
  - چرایی: کاهش زمان بارگذاری و مصرف منابع.
  - پیامد عدم انجام: لود کند و تجربه ضعیف.
  - گام اجرا: تحلیل باندل و اعمال بهینه‌سازی‌های هدفمند.

### مشاهده‌پذیری و سنجه‌ها
- ثبت RUM (Core Web Vitals) و هیستوگرام تأخیر API.
- آنالیتیکس استفاده از قابلیت‌ها برای اولویت‌بندی.
  - چرایی: تصمیم‌گیری مبتنی بر داده و پایش سلامت سیستم.
  - پیامد عدم انجام: حدس‌زدن به‌جای اندازه‌گیری.
  - گام اجرا: اضافه‌کردن ابزارک‌های اندازه‌گیری سمت کلاینت/سرور.

### استراتژی مهاجرت (برای اجرا در آینده)
- افزودن ستون‌های audit و ایندکس‌ها به‌صورت غیرشکننده (nullable/مقادیر پیش‌فرض امن).
- معرفی جدول مرکزی audit log؛ فعال‌سازی تدریجی تریگرها و مانیتورینگ سربار نوشتن.
- ارتقای تدریجی: شروع با ستون‌های درون‌جدولی؛ سپس فعال‌سازی لاگ مرکزی برای جداول با ارزش بالا.
  - چرایی: کاهش ریسک در تغییرات زیربنایی.
  - پیامد عدم انجام: توقف سرویس یا ناسازگاری داده.
  - گام اجرا: برنامه‌ زمان‌بندی شده، تهیه بکاپ و مانیتورینگ پس از انتشار.


